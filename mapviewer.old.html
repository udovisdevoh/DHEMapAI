<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Visualiseur de Carte DHEMap</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --viewer-bg: #2a2a2a;
            --control-bg: #333;
            --text-color: #f0f0f0;
            --border-color: #444;
            --accent-color: #0095d9;
            --tooltip-bg: rgba(0, 0, 0, 0.85);
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden;
        }
        header {
            padding: 10px 20px;
            background-color: var(--control-bg);
            border-bottom: 2px solid var(--border-color);
            text-align: center;
        }
        main {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }
        #controls {
            width: 280px;
            padding: 15px;
            background-color: var(--control-bg);
            border-right: 2px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .control-group {
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 15px;
        }
        .control-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
        }
        #viewer {
            flex-grow: 1;
            background-color: var(--viewer-bg);
            cursor: grab;
            position: relative;
        }
        #viewer.panning {
            cursor: grabbing;
        }
        #svg-container {
            width: 100%;
            height: 100%;
        }
        #tooltip {
            position: absolute;
            display: none;
            background-color: var(--tooltip-bg);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            pointer-events: none;
            white-space: pre;
            font-family: monospace;
            z-index: 1000;
            border: 1px solid #666;
        }
        .thing-emoji {
            font-size: 24px;
            text-anchor: middle;
            dominant-baseline: middle;
            cursor: pointer;
        }
        .sector-poly { transition: fill 0.2s; }
        .linedef-line { stroke-width: 2px; }
        .linedef-door { stroke-dasharray: 6, 4; }
        .linedef-exit { stroke: #ff5555; stroke-width: 4px; }
    </style>
</head>
<body>

    <header>
        <h1>Visualiseur de Carte DHEMap</h1>
    </header>

    <main>
        <aside id="controls">
            <div class="control-group">
                <label for="fileInput">Charger un fichier DHEMap</label>
                <input type="file" id="fileInput" accept=".dhemap,.json">
            </div>
            <div class="control-group">
                <label>Vue des Secteurs</label>
                <input type="radio" id="viewFloors" name="viewToggle" value="floor" checked>
                <label for="viewFloors">Planchers</label>
                <input type="radio" id="viewCeilings" name="viewToggle" value="ceiling">
                <label for="viewCeilings">Plafonds</label>
            </div>
             <div class="control-group">
                <label>L√©gende (Things)</label>
                <p>üòÄ Joueur &nbsp; üëø Monstre &nbsp; üî´ Arme</p>
                <p>üíä Soin &nbsp;üõ°Ô∏è Armure &nbsp;üóùÔ∏è Cl√©</p>
                <p>‚öôÔ∏è D√©cor &nbsp;‚ùì Autre</p>
            </div>
        </aside>

        <div id="viewer">
            <svg id="svg-container" width="100%" height="100%"></svg>
        </div>
    </main>

    <div id="tooltip"></div>

    <script>
    // --- DICTIONNAIRES DE COULEURS ET EMOJIS ---
    const FLAT_COLORS = {
        'default': '#555555', 'F_SKY1': '#87CEEB', 'FLOOR4_8': '#6B4423', 'FLAT14': '#708090',
        'CEIL3_1': '#4682B4', 'SLIME14': '#7CFC00', 'MFLR8_1': '#8B0000',
    };
    const TEXTURE_COLORS = {
        'default': '#FFFFFF', 'STARTAN2': '#8B4513', 'METAL': '#A9A9A9', 'DOORTRAK': '#696969',
        'SW1EXIT': '#FFFF00', 'EXITDOOR': '#FFD700', 'DOOR1': '#CD853F',
    };
    const THING_INFO = {
        'default': { emoji: '‚ùì', name: 'Inconnu' },
        1: { emoji: 'üòÄ', name: 'Joueur 1 D√©part' }, 2: { emoji: 'üòÄ', name: 'Joueur 2 D√©part' },
        3: { emoji: 'üòÄ', name: 'Joueur 3 D√©part' }, 4: { emoji: 'üòÄ', name: 'Joueur 4 D√©part' },
        11: { emoji: 'üòÄ', name: 'Point D√©part Deathmatch' },
        3001: { emoji: 'üëø', name: 'Imp' }, 3004: { emoji: 'üëø', name: 'Zombieman' },
        3002: { emoji: 'üëø', name: 'Demon' }, 68: { emoji: 'üëø', name: 'Spectre' },
        2007: { emoji: 'üî´', name: 'Fusil √† Pompe' }, 2001: { emoji: 'üî´', name: 'Fusil d\'Assaut' },
        2005: { emoji: 'üíä', name: 'Medikit' }, 2012: { emoji: 'üíä', name: 'Stimpack' },
        2018: { emoji: 'üõ°Ô∏è', name: 'Armure Verte' }, 2019: { emoji: 'üõ°Ô∏è', name: 'Armure Bleue' },
        5: { emoji: 'üóùÔ∏è', name: 'Cl√© Bleue' }, 13: { emoji: 'üóùÔ∏è', name: 'Cl√© Jaune' },
        30: { emoji: '‚öôÔ∏è', name: 'Pilier Vert' },
    };

    function getColor(type, name) {
        const dict = type === 'flat' ? FLAT_COLORS : TEXTURE_COLORS;
        name = name.toUpperCase();
        for (const key in dict) {
            if (name.startsWith(key)) return dict[key];
        }
        return dict.default;
    }
    function getThingInfo(type) {
        return THING_INFO[type] || THING_INFO.default;
    }

    // --- GESTION DU SVG ET DE LA VUE ---
    const svg = document.getElementById('svg-container');
    const viewer = document.getElementById('viewer');
    const tooltip = document.getElementById('tooltip');
    let g; // Le groupe principal pour le pan/zoom

    let viewBox = { x: 0, y: 0, w: 1000, h: 1000 };
    let isPanning = false;
    let startPoint = { x: 0, y: 0 };

    function updateViewBox() {
        svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
    }

    // --- CHARGEMENT ET RENDU DE LA CARTE ---
    const fileInput = document.getElementById('fileInput');
    fileInput.addEventListener('change', handleFileSelect, false);

    function handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const dhemap = JSON.parse(e.target.result);
                renderMap(dhemap);
            } catch (error) {
                alert('Erreur: Le fichier JSON est invalide.\n' + error.message);
            }
        };
        reader.readAsText(file);
    }

    function renderMap(dhemap) {
        // Nettoyer l'ancien contenu
        svg.innerHTML = '';
        g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        svg.appendChild(g);

        const allX = dhemap.vertices.map(v => v.x);
        const allY = dhemap.vertices.map(v => v.y);
        const minX = Math.min(...allX); const maxX = Math.max(...allX);
        const minY = Math.min(...allY); const maxY = Math.max(...allY);
        
        const mapWidth = maxX - minX;
        const mapHeight = maxY - minY;
        const padding = Math.max(mapWidth, mapHeight) * 0.1;

        viewBox = {
            x: minX - padding,
            y: -(maxY + padding), // Inversion de Y ici
            w: mapWidth + padding * 2,
            h: mapHeight + padding * 2,
        };
        g.setAttribute('transform', 'scale(1, -1)'); // Inverser l'axe Y pour tout le groupe
        updateViewBox();
        
        // Cr√©er des dictionnaires pour un acc√®s rapide
        const vertexDict = new Map(dhemap.vertices.map(v => [v.id, v]));
        const sidedefDict = new Map(dhemap.sidedefs.map(s => [s.id, s]));
        const sectorDict = new Map(dhemap.sectors.map(s => [s.id, s]));

        // 1. Rendu des Secteurs
        const sectorLinedefs = {};
        dhemap.linedefs.forEach(line => {
            const frontSidedef = sidedefDict.get(line.frontSidedef);
            if (frontSidedef) {
                if (!sectorLinedefs[frontSidedef.sector]) sectorLinedefs[frontSidedef.sector] = [];
                sectorLinedefs[frontSidedef.sector].push(line);
            }
            if (line.backSidedef != null) {
                const backSidedef = sidedefDict.get(line.backSidedef);
                if (backSidedef) {
                    if (!sectorLinedefs[backSidedef.sector]) sectorLinedefs[backSidedef.sector] = [];
                    sectorLinedefs[backSidedef.sector].push(line);
                }
            }
        });

        dhemap.sectors.forEach(sector => {
            const linesForSector = sectorLinedefs[sector.id] || [];
            if(linesForSector.length === 0) return;
            
            // Algorithme simple pour ordonner les vertices d'un secteur
            const orderedVertices = [];
            const remainingLines = [...linesForSector];
            let currentLine = remainingLines.pop();
            let currentSidedef = sidedefDict.get(currentLine.frontSidedef)?.sector === sector.id ? sidedefDict.get(currentLine.frontSidedef) : sidedefDict.get(currentLine.backSidedef);
            let isReversed = (sidedefDict.get(currentLine.backSidedef)?.sector === sector.id);

            orderedVertices.push(isReversed ? vertexDict.get(currentLine.endVertex) : vertexDict.get(currentLine.startVertex));
            let nextVertexId = isReversed ? currentLine.startVertex : currentLine.endVertex;
            
            while(remainingLines.length > 0) {
                 let found = false;
                 for(let i=0; i < remainingLines.length; i++) {
                    let nextLine = remainingLines[i];
                    if(nextLine.startVertex === nextVertexId || nextLine.endVertex === nextVertexId) {
                        isReversed = nextLine.endVertex === nextVertexId;
                        orderedVertices.push(vertexDict.get(nextVertexId));
                        nextVertexId = isReversed ? nextLine.startVertex : nextLine.endVertex;
                        remainingLines.splice(i, 1);
                        found = true;
                        break;
                    }
                 }
                 if(!found) break; // Arr√™ter si le secteur n'est pas ferm√©
            }

            const points = orderedVertices.map(v => `${v.x},${v.y}`).join(' ');
            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.setAttribute('points', points);
            polygon.setAttribute('class', 'sector-poly');
            polygon.dataset.sectorId = sector.id;
            polygon.dataset.floorTexture = sector.floorTexture;
            polygon.dataset.ceilingTexture = sector.ceilingTexture;
            polygon.dataset.info = `SECTEUR ${sector.id}\nPlancher: ${sector.floorTexture} (H:${sector.floorHeight})\nPlafond: ${sector.ceilingTexture} (H:${sector.ceilingHeight})\nLumi√®re: ${sector.lightLevel}\nTag: ${sector.tag}`;
            polygon.style.fill = getColor('flat', sector.floorTexture);
            g.appendChild(polygon);
        });

        // 2. Rendu des Linedefs
        dhemap.linedefs.forEach(line => {
            const v1 = vertexDict.get(line.startVertex);
            const v2 = vertexDict.get(line.endVertex);
            const svgLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            svgLine.setAttribute('x1', v1.x); svgLine.setAttribute('y1', v1.y);
            svgLine.setAttribute('x2', v2.x); svgLine.setAttribute('y2', v2.y);
            
            const frontSidedef = sidedefDict.get(line.frontSidedef);
            let lineInfo = `LINEDEF ${line.id}`;
            let color = TEXTURE_COLORS.default;
            if (frontSidedef) {
                lineInfo += `\nFront: ${frontSidedef.textureMiddle}`;
                color = getColor('texture', frontSidedef.textureMiddle);
            }
             if (line.backSidedef != null) {
                const backSidedef = sidedefDict.get(line.backSidedef);
                if (backSidedef) lineInfo += `\nBack: ${backSidedef.textureMiddle}`;
             }

            let className = 'linedef-line';
            if (line.action?.special === 1 || line.action?.special === 26) { // Porte
                className += ' linedef-door';
                lineInfo += `\nACTION: Porte (Tag ${line.action.tag})`;
            }
            if (line.action?.special === 11) { // Sortie
                className += ' linedef-exit';
                lineInfo += `\nACTION: Sortie du niveau`;
            }
            svgLine.setAttribute('class', className);
            svgLine.style.stroke = color;
            svgLine.dataset.info = lineInfo;
            g.appendChild(svgLine);
        });

        // 3. Rendu des Things
        dhemap.things.forEach(thing => {
            const info = getThingInfo(thing.type);
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', thing.x);
            text.setAttribute('y', thing.y);
            text.setAttribute('class', 'thing-emoji');
            text.setAttribute('transform', `scale(1, -1) translate(${thing.x*2}, -${thing.y*2}) rotate(${-thing.angle}, ${thing.x}, ${thing.y}) scale(1,-1)`);
            text.textContent = info.emoji;
            text.dataset.info = `THING ${thing.id}\n${info.name}\nType: ${thing.type}\nAngle: ${thing.angle}`;
            g.appendChild(text);
        });
    }
    
    // --- GESTION DES √âV√âNEMENTS ---
    
    // Tooltips
    svg.addEventListener('mouseover', e => {
        if (e.target && e.target.dataset.info) {
            tooltip.style.display = 'block';
            tooltip.textContent = e.target.dataset.info;
        }
    });
    svg.addEventListener('mouseout', () => { tooltip.style.display = 'none'; });
    svg.addEventListener('mousemove', e => {
        tooltip.style.left = (e.clientX + 15) + 'px';
        tooltip.style.top = (e.clientY + 15) + 'px';
    });

    // Vue Plancher/Plafond
    document.querySelectorAll('input[name="viewToggle"]').forEach(radio => {
        radio.addEventListener('change', e => {
            const viewType = e.target.value;
            document.querySelectorAll('.sector-poly').forEach(poly => {
                const texture = viewType === 'floor' ? poly.dataset.floorTexture : poly.dataset.ceilingTexture;
                poly.style.fill = getColor('flat', texture);
            });
        });
    });

    // Pan & Zoom
    viewer.addEventListener('mousedown', e => {
        isPanning = true;
        startPoint = { x: e.x, y: e.y };
        viewer.classList.add('panning');
    });
    viewer.addEventListener('mousemove', e => {
        if (!isPanning) return;
        const endPoint = { x: e.x, y: e.y };
        const dx = (endPoint.x - startPoint.x) * (viewBox.w / viewer.clientWidth);
        const dy = (endPoint.y - startPoint.y) * (viewBox.h / viewer.clientHeight);
        viewBox.x -= dx;
        viewBox.y += dy; // Inversion de Y ici aussi
        updateViewBox();
        startPoint = endPoint;
    });
    viewer.addEventListener('mouseup', () => { isPanning = false; viewer.classList.remove('panning'); });
    viewer.addEventListener('mouseleave', () => { isPanning = false; viewer.classList.remove('panning'); });
    viewer.addEventListener('wheel', e => {
        e.preventDefault();
        const zoomIntensity = 0.1;
        const direction = e.deltaY > 0 ? 1 : -1;
        const zoomFactor = 1 + direction * zoomIntensity;
        
        const mousePoint = { x: e.offsetX, y: e.offsetY };
        const svgPoint = {
            x: viewBox.x + mousePoint.x * (viewBox.w / viewer.clientWidth),
            y: viewBox.y + mousePoint.y * (viewBox.h / viewer.clientHeight),
        };
        
        viewBox.w *= zoomFactor;
        viewBox.h *= zoomFactor;
        viewBox.x = svgPoint.x - mousePoint.x * (viewBox.w / viewer.clientWidth);
        viewBox.y = svgPoint.y - mousePoint.y * (viewBox.h / viewer.clientHeight);
        
        updateViewBox();
    });

    </script>
</body>
</html>